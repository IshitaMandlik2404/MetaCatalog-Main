import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import { connect } from "databricks-sql";
import jwt from "jsonwebtoken";  // ← NEW: npm install jsonwebtoken

dotenv.config();

const app = express();
app.use(cors({ origin: ["http://localhost:3000"], credentials: true }));  // ← Allow credentials for JWT
app.use(express.json());

// ---- Helper: run parameterized query ----
async function runQuery(sqlText, parameters = []) {
  const conn = await connect({
    serverHostname: process.env.DATABRICKS_HOST,
    httpPath: process.env.DATABRICKS_HTTP_PATH,
    accessToken: process.env.DATABRICKS_TOKEN,
  });

  try {
    const stmt = await conn.execute({ sqlText, parameters });
    const rows = await stmt.fetchAll();
    await stmt.close();
    await conn.close();
    return rows;
  } catch (err) {
    try { await conn.close(); } catch {}
    throw err;
  }
}

// ---- JWT Middleware for role protection ----
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'your-super-secret-key-2026', (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;  // { username, role, userId }
    next();
  });
};

const requireRole = (...allowedRoles) => (req, res, next) => {
  if (!allowedRoles.includes(req.user.role)) {
    return res.status(403).json({ 
      error: `Role ${req.user.role} not authorized. Requires: ${allowedRoles.join(', ')}` 
    });
  }
  next();
};

// ---- NEW: Users table operations ----
const USERS_TABLE = 'metacatalog.metaschema.users';

// Create users table (run once)
app.post('/api/users/setup', async (req, res) => {
  try {
    await runQuery(`
      CREATE TABLE IF NOT EXISTS ${USERS_TABLE} (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        username VARCHAR(100) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        role VARCHAR(20) NOT NULL CHECK(role IN('admin','editor','viewer')),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert test users if empty
    const countResult = await runQuery(`SELECT COUNT(*) as count FROM ${USERS_TABLE}`);
    if (countResult[0]?.count === 0) {
      await runQuery(`
        INSERT INTO ${USERS_TABLE} (username, password, role) VALUES
        ('admin@test.com', 'adminpass', 'admin'),
        ('editor@test.com', 'editorpass', 'editor'),
        ('viewer@test.com', 'viewerpass', 'viewer')
      `);
      console.log('Test users created');
    }
    
    res.json({ status: 'Users table ready', testUsers: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ---- NEW: Role-based login ----
app.post('/api/login', async (req, res) => {
  try {
    const { username, password, role } = req.body;
    
    if (!username || !password || !['admin', 'editor', 'viewer'].includes(role)) {
      return res.status(400).json({ error: 'Invalid credentials or role' });
    }

    const rows = await runQuery(
      `SELECT * FROM ${USERS_TABLE} WHERE username = ? AND password = ?`,
      [username, password]
    );
    
    const user = rows[0];
    if (!user || user.ROLE !== role) {
      return res.status(401).json({ error: 'Invalid credentials or role mismatch' });
    }

    const token = jwt.sign({ 
      username: user.USERNAME,
      role: user.ROLE,
      userId: user.ID 
    }, process.env.JWT_SECRET || 'your-super-secret-key-2026', { expiresIn: '24h' });

    res.json({ 
      token, 
      user: { username: user.USERNAME, role: user.ROLE },
      message: 'Login successful' 
    });
  } catch (e) {
    console.error('[ERR] /api/login', e);
    res.status(500).json({ error: e.message });
  }
});

// ---- YOUR EXISTING ENDPOINTS (now optionally protected) ----
app.get("/api/catalog-names", async (req, res) => {
  try {
    const rows = await runQuery(`
      SELECT DISTINCT catalog_name
      FROM metacatalog.metaschema.business_catalog_metadata_healthcare
      ORDER BY catalog_name
    `);
    const names = rows.map(r => r.CATALOG_NAME || r.catalog_name);
    res.json({ data: names });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get("/api/catalog-metadata", async (req, res) => {
  const { catalog_name, attribute_type } = req.query;
  if (!catalog_name) return res.status(400).json({ error: "catalog_name is required" });
  if (!attribute_type) return res.status(400).json({ error: "attribute_type is required" });

  try {
    const rows = await runQuery(
      `
      SELECT DISTINCT attribute_value
      FROM metacatalog.metaschema.business_catalog_metadata_healthcare
      WHERE catalog_name = ?
        AND attribute_type = ?
      ORDER BY attribute_value
      `,
      [catalog_name, attribute_type]
    );
    const values = rows.map(r => r.ATTRIBUTE_VALUE || r.attribute_value);
    res.json({ data: values });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get("/api/catalog-metadata-all", async (req, res) => {
  const { catalog_name } = req.query;
  if (!catalog_name) return res.status(400).json({ error: "catalog_name is required" });
  try {
    const rows = await runQuery(
      `
      SELECT attribute_type, attribute_value
      FROM metacatalog.metaschema.business_catalog_metadata_healthcare
      WHERE catalog_name = ?
      ORDER BY attribute_type, attribute_value
      `,
      [catalog_name]
    );
    const result = {};
    rows.forEach(r => {
      const t = r.ATTRIBUTE_TYPE || r.attribute_type;
      const v = r.ATTRIBUTE_VALUE || r.attribute_value;
      result[t] = result[t] || [];
      result[t].push(v);
    });
    res.json({ data: result });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ---- NEW: Protected example (Admin/Editor only) ----
app.get('/api/admin-metadata', authenticateToken, requireRole('admin', 'editor'), async (req, res) => {
  res.json({ 
    message: 'Admin/Editor only data', 
    userRole: req.user.role,
    data: 'Sensitive metadata here' 
  });
});

app.listen(process.env.PORT || 5001, () =>
  console.log(`Backend running on port ${process.env.PORT || 5001}`)
);
// ---- AUTO ROLE FROM DATABRICKS TABLE ----
app.get('/api/user-role', async (req, res) => {
  try {
    const { username } = req.query;  // From MSAL accounts[0].username
    if (!username) return res.status(400).json({ error: 'username required' });

    // Query your table for user role (adjust column names per screenshot)
    const rows = await runQuery(`
      SELECT attribute_value as role
      FROM metacatalog.metaschema.business_metadata_config 
      WHERE attribute_type = 'role' 
        AND subject = ?
      ORDER BY created_at DESC 
      LIMIT 1
    `, [username]);

    const role = rows[0]?.role || 'viewer';  // Default viewer
    console.log(`[ROLE] ${username} → ${role}`);

    res.json({ role, username });
  } catch (err) {
    console.error('[ERR] /api/user-role', err);
    res.status(500).json({ error: err.message });
  }
});

